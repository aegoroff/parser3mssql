Примечания:

1. Нет транзакций "по-умолчанию", т.е. неявных транзакций на каждый запрос, которые делает, например ODBC драйвер. Не сделал потому что считаю пользователь сам может их делать (если ему нужно), используя BEGIN TRAN, COMMIT TRAN, ROLLBACK
2. Можно выполнять хранимые процедуры и получать результаты и в виде скаляра(int, double string etc) и в виде таблицы.
3. Поддерживается и Windows Integrated security и SQL Server security
4. Поддерживаются параметризованные запросы с позиционными параметрами (не именованными, которые ещё предстоит сделать). Что это такое?:
Параметризованный запрос с позиционными параметрами представляет запрос вида:
SELECT c1, c2 FROM t WHERE c1 = ? AND c2 = ?
Где знаки вопроса в запросе и представляют собой ссылки на параметры содержащие данные. Первый знак ссылка на первый параметр, второй на второй и так далее. 
Сами параметры передаются с помощью хэша bind. Пример:
$t[^table::sql{SELECT c1, c2 FROM t WHERE c1 = ? AND c2 = ?}[
		$.bind[ 
			$.1[Вася Пупкин]
			$.2(30)
		]
	]
]

Имена ключей хэша соответсвуют позиции параметра в запросе. Если встречается имя которое невозможно преобразовать в число или
его значение выходит за границы диапазона 1-<количество параметров> - выбрасывается исключение.

ВАЖНО: Нумерация параметров начинается с единицы.

Зачем это нужно? Это нужно для защиты от так называемых SQL инъекций, когда данные принимаемые от пользователя вставляются в SQL запрос. Кроме того,
может существовать ограничение на максимально допустимый размер текста запроса за который можно легко выйти
передав в условие WHERE большую строку. Существует ещё много способов применений данного типа запросов.

Формат строки подключения:

Windows Integrated: mssql://server=<server>^;database=<database>^;Trusted_Connection=Yes
SQL Server: mssql://Server=<server>^;Database=<database>^;Uid=<login>^;Pwd=<password>

Замечания по limit и offset:

В связи с тем, что в MS SQL отсутствует опция offset, имеющаяся в MySQL, сделать эффективную реализацию поведения limit и offset используя средства парсера, не представляется возможным в общем случае (для простых случаев можно, но это не выход). Поэтому, текущая реализация этой опции, крайне неэффективна (как и в ODBC драйвере). Я подумываю о том, чтобы просто это запретить при использовании этого драйвера (путем выброса исключения). Но выход есть. Необходимо просто формировать SQL запросы соответствующим образом. Схема следующая:

select top <limit>... from <table> where <pk> not in (select top <offset> <pk> from <table>  [order by <fields>]) [order by <fields>]

Подключение драйвера:

mssql	<path>\parser3mssql.dll	

Для работы необходимо поставить Собственный клиент Microsoft SQL Server(Microsoft SQL Server 2005 Native Client) http://www.microsoft.com/downloads/details.aspx?FamilyId=50b97994-8453-4998-8226-fa42ec403d17&DisplayLang=ru 
брать файл sqlncli.msi
